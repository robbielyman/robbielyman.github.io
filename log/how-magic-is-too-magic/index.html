<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="UTF-8">
    <meta name="description" content="alanza.xyz: Robbie Lyman">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="Robbie Lyman">
    <meta name="twitter:author" content="Robbie Lyman">
    <meta name="twitter:description" content="alanza.xyz: Robbie Lyman">
    <meta name="twitter:title" content="How magic is too magic? Personalities of programming languages | alanza.xyz">
    <meta name="twitter:image" content="https://alanza.xyz/headshot.jpeg">
    <meta property="og:type" content="website">
    <meta property="og:title" conten="How magic is too magic? Personalities of programming languages | alanza.xyz">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title id="title">
      How magic is too magic? Personalities of programming languages
      - alanza.xyz
    </title>
    <link rel="stylesheet" type="text/css" href="/fonts.css">
    <link rel="stylesheet" type="text/css" href="/style.css">
    <link rel="stylesheet" type="text/css" href="/highlight.css">
    <link href="https://merveilles.town/@alanza" rel="me">
    
    
  </head>
  <body>
    <nav id="menu" class="centered">
      <a href="/">Home</a>
      •
      <a href="/math/">Math</a>
      •
      <a href="https://github.com/robbielyman">Code</a>
      •
      <a href="/log/">Blog</a>
      •
      <a href="/devlog/">Devlog</a>
    </nav>
    <div id="content">
      
  <h3 class="overtitle centered">Blog – alanza.xyz</h3>
  <h1 class="centered title">ROBBIE LYMAN</h1>
  <h3 class="centered subtitle">How magic is too magic? Personalities of programming languages</h3>
  <div id="blog-navigation">
    <div id="left">
      <a href="/log/announcing-zosc/">Previous</a>:
      <span>Announcing zOSC</span>
    </div>
    <div id="center">
      <a href="/log/">Up</a>
    </div>
    <div id="right"></div>
  </div>
  <div id="page">
    <div><div id=summary><p> I’ve heard people observe that although we often think of language as purely a medium for expressing something that exists prior to language, that the words available to us shape who we are as well. I think there’s some truth to this: I took four semesters of Japanese in grad school—not enough to approach fluency without intensive immersion, but plenty to start feeling out the language. I found that at the time my personality as expressed in Japanese was a bit more cautious than I am in English.</p><p>It’s interesting to observe that this difference in what I <em>want</em> to express and <em>how</em> is also present for me in programming. Not every language I’ve written a line of has a personality for me yet—mostly this correlates with how seriously I’ve learned what the language has to offer, but interestingly as I’ve improved as a programmer, the personality associations have also started coming faster.</p></div></div>    
    <div class="toc"><ul>
<li>Comparing three languages</li><li>Lua types<ul><li>
Userdata and metatables</li></ul></ul></div>
    <div><div id=remainder><p>The languages I know best are Zig, Lua and Rust, each of which comes with very different goals and assumptions, lending to a different style in terms of what feels fun to do.</p><h1>Comparing three languages</h1><p>Of these three, I think it’s obvious that Zig is the most serious programming language. It prides itself on having “no hidden control flow”, for example, hands you control (if you want it) over the memory layout of types, and requires you to manage memory correctly. That’s not to say Zig isn’t fun: when <a href="https://github.com/robbielyman/uxn-zig">I implemented</a> the <a href="https://100r.co/site/uxn.html">Uxn</a> virtual machine, I was able to define my own type which takes up one byte of space, but treats each bit of that byte correctly as either a “mode flag” or as part of a list of instructions. Whereas in C one has to do bitwise arithmetic directly, in Zig you can ask whether a bit is set as if it were a regular boolean, or switch on only the enum field of the byte-sized struct. Other classic metaprogramming tasks are also a joy in Zig, simply because they realized that programming Zig should be done in Zig, even if the purpose of that code is to construct a generic type and so the code runs at <em>compile time</em> instead of run time.</p><p>Rust, by comparison, is positively loosey-goosey. I’ve read too many complaints that Rust is hard because of the borrow checker and having to think about ownership. I could be wrong, but I think the reason for these complaints is because Rust was born as a Haskell that realized it could come for C++’s crown, but has morphed instead into a JavaScript run on that most virtual of machines, the actual CPU.</p><p>When you think about it using these frames, Rust is a joy to write. The borrow checker makes powerful, “zero-cost” abstractions possible, like copy-on-write structures, reference counting, <code>Impl Drop for T</code> running arbitrary code, closures, iterators, etc. Combine this with implicit returns and chainable methods, and you get the ability to write these beautifully terse koans that through the magic of LLVM are somehow also fast too. I love writing Rust; it makes me want to give it a noogie. Is your object on the stack or the heap? You actually probably don’t get to know, but as long as you and the borrow checker agree, you don’t really need to, either.</p><p>Lua is interesting. On the one hand, somehow the <code>do</code> and the <code>then</code> and the <code>function</code> spelled all the way out like that give it a certain amount of clunk. On the other hand, if you’re willing to venture into the corners of the language, magic is truly possible. I want to spend the rest of this post describing a use of the Lua API that I’m pretty proud of.</p><h1>Lua types</h1><p>Lua has very few types; this is to facilitate holding the entire language in your head as much as possible. Here is the full list: <code>nil</code>, <code>boolean</code>, <code>number</code> (integers, interestingly, exist as a bit of an odd subtype), <code>string</code>, <code>table</code>, <code>userdata</code>, “light userdata”, <code>thread</code> (really “coroutine” or “stack”) and <code>function</code>. Light userdata differ from “full” userdata in two ways: from C’s (or Zig’s) perspective, light userdata are just pointers; the object they point to is not in Lua’s universe so is not subject to garbage collection and mostly just sleets through the Lua environment undisturbed; their purpose is largely to enable Lua functions implemented in C to get handles to relevant data from the host environment. That’s one way; the other is that light userdata cannot be operated on—you can ask whether they’re equal (that’s just whether the addresses are equal), but you can’t index into them like you can a table.</p><h2>Userdata and metatables</h2><p>Full userdata, on the other hand, are also “just pointers” from C’s perspective, but the memory they point to is owned by the Lua environment, so is subject to garbage collection. In contrast to light userdata, full userdata may be made to behave more or less in the way that Lua tables do by providing a <em>metatable</em> for them.</p><p>A metatable is what it sounds like. I’m so sorry for writing that, but it’s true; at least in the common sense of “meta” as “referring to its own category”. functionally in Lua, the point of tables is that you can index into them. (They’re an interesting mix between an array and a hash map.) When a table <code>t</code> is missing a key <code>k</code>, but <code>t</code> has a metatable <code>mt</code>, the Lua virtual machine will query <code>mt</code> for its <code>__index</code> metamethod. If <code>__index</code> is a table, what you get will be <code>mt.__index[k]</code>. Otherwise if <code>__index</code> is a function, what you get is the result of <code>mt.__index(t, k)</code>. There is also a <code>__newindex</code> metamethod. Metatables provide other functionality too: for example, if you want to be able to add two tables together, you can do that with an <code>__add</code> metamethod. Or you want to <code>__call</code> a table as if it were a function? That’s allowed!</p><p>The interesting thing about this is that because functions are code, this means you can really go wild. An initial draft of this post intended to go further into this observation. Given that that post stalled out for a month, let me close by offering the following summary of it:</p><p>In my v2.0.0 rewrite of <a href="https://github.com/robbielyman/seamstress">seamstress</a>, an "art engine" and batteries-included Lua runtime, I have a <code>Timer</code> object type. From the perspective of the Zig code that implements it, a <code>Timer</code> is a little struct whose purpose is to sit on the seamstress event loop. From the perspective of Lua, a <code>Timer</code> has several builtin fields, perhaps the most interesting from today's perspective of which is named <code>running</code>. If <code>t</code> is an object of type <code>seamstress.Timer</code>, altering <code>t.running</code> from <code>true</code> to <code>false</code> executes code (like all code...) with the goal of removing the <code>Timer</code> from the event loop. In a language like Zig I would be aghast at this, since calling several functions as a result of setting a boolean feels like the definition of hidden control flow. Even as a writer of Rust I would probably balk at this. But in Lua? Bring it on.</p></div></div>
  </div>

    </div>
    <div id="footer-links">
      <img src="/rc_logo.png" style="height:1em;
      width:auto;">
      Want to become a better programmer?
      <a href="https://www.recurse.com/scout/click?t=481004d6b700a153d74901f056b2c9f0">
        Join the Recurse Center!
      </a>
    </div>
  </body>
</html>
