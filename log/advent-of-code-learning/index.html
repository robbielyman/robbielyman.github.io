<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="UTF-8">
    <meta name="description" content="alanza.xyz: Robbie Lyman">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="Robbie Lyman">
    <meta name="twitter:author" content="Robbie Lyman">
    <meta name="twitter:description" content="alanza.xyz: Robbie Lyman">
    <meta name="twitter:title" content="What I learned from Advent Of Code, or: That time I wrote a blog post and linked to it in the Zig issue tracker | alanza.xyz">
    <meta name="twitter:image" content="https://alanza.xyz/headshot.jpeg">
    <meta property="og:type" content="website">
    <meta property="og:title" conten="What I learned from Advent Of Code, or: That time I wrote a blog post and linked to it in the Zig issue tracker | alanza.xyz">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title id="title">
      What I learned from Advent Of Code, or: That time I wrote a blog post and linked to it in the Zig issue tracker
      - alanza.xyz
    </title>
    <link rel="stylesheet" type="text/css" href="/fonts.css">
    <link rel="stylesheet" type="text/css" href="/style.css">
    <link rel="stylesheet" type="text/css" href="/highlight.css">
    <link href="https://merveilles.town/@alanza" rel="me">
    
    
  </head>
  <body>
    <nav id="menu" class="centered">
      <a href="/">Home</a>
      •
      <a href="/math/">Math</a>
      •
      <a href="https://github.com/robbielyman">Code</a>
      •
      <a href="/log/">Blog</a>
      •
      <a href="/devlog/">Devlog</a>
    </nav>
    <div id="content">
      
  <h3 class="overtitle centered">Blog – alanza.xyz</h3>
  <h1 class="centered title">ROBBIE LYMAN</h1>
  <h3 class="centered subtitle">What I learned from Advent Of Code, or: That time I wrote a blog post and linked to it in the Zig issue tracker</h3>
  <div id="blog-navigation">
    <div id="left">
      <a href="/log/double-cosets-are-edges/">Previous</a>:
      <span>Double cosets are edges</span>
    </div>
    <div id="center">
      <a href="/log/">Up</a>
    </div>
    <div id="right">
      <a href="/log/just-write-the-function/">Next</a>:
      <span>Just write the function!</span>
    </div>
  </div>
  <div id="page">
    <div><div id=summary><p>I’m doing Advent of Code again this year; so far I’ve been very pleasantly surprised that my facility for solving the problems has improved. (Of course, I’m well aware that the difficulty is likely to ramp up soon, so I may end up eating my words.) Previously, I did the 2023 Advent of Code as it happened in Zig. <em>Pace</em> Loris Cro, <a href="https://kristoff.it/blog/advent-of-code-zig/">who wrote a great blog post on the subject</a>, I think that despite the way Advent of Code problems are at odds with the kinds of software problems that Zig aims itself at solving, doing Advent of Code is a great way to gain familiarity with Zig. Over this past summer I also did the 2022 Advent of Code problems as a way of learning Rust. Today, solving the 5th problem for 2024, it occurred to me that Rust had taught me something surprisingly useful for my Zig solution. The purpose of this post is to talk about what I learned—this post does not contain spoilers for any Advent of Code problems, and indeed is not really “about” Advent of Code at all: as I was writing it, it became clear that part of this blog post actually belongs on the Zig issue tracker.</p></div></div>    
    <div class="toc"><ul>
<li>All I know is eat hot chip and <code>Impl Iterator</code></li><li>Containers? Use ’em</li><li>Managed vs. Unmanaged and ArrayLists<ul><li>
Initialization</li><li>Size</li><li>Optimizability</li></ul></ul></div>
    <div><div id=remainder><h1>All I know is eat hot chip and <code>Impl Iterator</code></h1><p>In my opinion, both Rust and Zig have (very different!) hard edges that ultimately lead you towards writing better programs. The “obvious” hard edge that Rust has is the borrow checker, which other people have beaten to death. The borrow checker is a beautiful piece of software; I’m not interested in discussing it here.</p><p>No, with Rust i was so immediately taken with the <code>Iterator</code> trait and the ease of creating <code>Vecs</code> and <code>HashSets</code> and so forth with <code>.collect()</code> that i spent a large amount of thought while ramping up with the first several problems so that my processing of the input could go something like</p><pre><code class="rust"><span class="keyword">fn</span> <span class="function">process</span><span class="punctuation bracket">(</span><span class="variable parameter">input</span><span class="punctuation delimiter">:</span> <span class="operator">&</span><span class="type builtin">str</span><span class="punctuation bracket">)</span> -&gt; <span class="type builtin">u32</span> <span class="punctuation bracket">{</span>
	<span class="constant">input</span><span class="punctuation delimiter">.</span><span class="function method">lines</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span>
	    <span class="punctuation delimiter">.</span><span class="function method">map</span><span class="punctuation bracket">(</span>|<span class="constant">line</span>| <span class="punctuation bracket">{</span> ..<span class="punctuation delimiter">.</span><span class="property"></span> <span class="punctuation bracket">}</span><span class="punctuation bracket">)</span>
	    <span class="comment">// ...</span>
	    <span class="punctuation delimiter">.</span><span class="function method">fold</span><span class="punctuation bracket">(</span>..<span class="punctuation delimiter">.</span><span class="property"></span><span class="punctuation bracket">)</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>I write more procedurally in Zig (which doesn't have first-class support for "generic" iteration processing like <code>map</code> or <code>fold</code> or first-class closures), which I think is an instance of a Zig hard edge that improves correctness (more on this another time, I guess), but Rust's affordance for it taught me a lot in terms of rigorous thinking about scope and clarity of purpose: each iterator chain exists to transform an input to an output—it doesn't have access the full input or other context unless you correctly make that available to it. (Correctly in the sense of the borrow checker.) Paradoxically, even though <code>process</code> is provided the full file as input, this <code>impl Iterator</code> code structure also promotes a "streaming" mentality for processing the data; I find I don't create more than is actually necessary.</p><p>By the way, I’d argue that passing the entire file contents to this function is always correct: Advent of Code text files are small, even when they stretch into the kilobytes—that's a small number in comparison to my total RAM, I try to keep in mind. Additionally, the <code>input</code> parameter introduces the correct <a href="https://notes.nicole.computer/notes/Code-Seams" target="_blank">“code seam” (thanks Nicole Watts for a beautiful new-to-me metaphor!)</a> for testing your solution.</p><h1>Containers? Use ’em</h1><p>That's kind of the high-minded thing Rust taught me. The other thing I learned via doing Advent of Code in Rust is feeling comfortable using the containers it provides. Rust makes this easier than Zig as of 0.13 on a name level—if you want a growable array of objects, all of type <code>T</code>, what you want is a <code>Vec&lt;T&gt;</code>. If you want to start with a collection of objects, you can construct one with the <code>vec!</code> macro. If you want to deduplicate a list, what you want is a <code>HashSet&lt;T&gt;</code>, or if you want to associate keys to values, you want a <code>HashMap&lt;K,V&gt;</code>. The <code>Vec</code> type is so common it's imported into every Rust scope, but making <code>HashSet</code> and <code>HashMap</code> available to you is not difficult.</p><p>Zig does great on this front, actually; it has great default implementations of all of these container types. They're just named poorly. One instance of poor name choices is already being corrected for Zig 0.14. I'll save discussing that for later. First, I'd like to argue for another change towards better defaults.</p><p>In Zig, here is the signature of <code>std.HashMap</code>:</p><pre><code class="zig"><span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">HashMap</span><span class="punctuation bracket">(</span><span class="attribute">comptime</span> <span class="parameter">K</span><span class="punctuation delimiter">:</span> <span class="type builtin">type</span><span class="punctuation delimiter">,</span> 
	<span class="attribute">comptime</span> <span class="parameter">V</span><span class="punctuation delimiter">:</span> <span class="type builtin">type</span><span class="punctuation delimiter">,</span> 
	<span class="attribute">comptime</span> <span class="parameter">Context</span><span class="punctuation delimiter">:</span> <span class="type builtin">type</span><span class="punctuation delimiter">,</span> 
	<span class="attribute">comptime</span> <span class="parameter">max_load_percentage</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">)</span> <span class="type builtin">type</span> <span class="punctuation bracket">{</span> <span class="error">...</span> <span class="punctuation bracket">}</span>
</code></pre>
<p>(Yes, that's a function. In Zig, to create a type that depends on another type, y ou write a function which takes in a parameter like <code>comptime T: type</code> and returns a <code>type</code>. This saves you from having to write generics using a thornier sublanguage instead of regular Zig.)</p><p>The <code>Context</code> type is responsible for actually hashing keys of type <code>K</code> and determining when two keys are the same. You can write a <code>Context</code> type yourself without crying too much; for Advent of Code 2023, I did—<strong>for the simple and sad reason that this type has the best name,</strong> while the type that actually deserves the best name does not.</p><p>As of Zig 0.13, I will confidently assert that the type you want maybe 90% of the time you reach for a <code>std.HashMap</code> is actually one of <code>std.AutoHashMapUnmanaged(K, V)</code>, <code>std.AutoArrayHashMapUnmanaged(K, V)</code>, or in the particular case of string keys, <code>std.StringHashMapUnmanaged</code> or <code>std.StringArrayHashMapUnmanaged</code>.</p><p>The <code>Unmanaged</code> issue, as I alluded to earlier, is being fixed already. If the issue of the <code>Auto</code> prefix is not already being changed, I'd like to propose that it should be.</p><p>Here <code>Auto</code> means "use a best guess at a default hashing function". (<code>Array</code> means store keys and values contiguously so that iterating over them is fast and ergonomic. I read somewhere that even iterating once is enough to justify reaching for this type.) It's great that Zig allows you to swap out the default (or even <code>std</code>-provided) methods for hashing with your own. The "ground" types <code>HashMapUnmanaged</code> and <code>ArrayHashMapUnmanaged</code> are well thought through in terms of API design. My issue with them is that for a beginner, they shadow the correct type to reach for first.</p><p>I propose that current <code>std.HashMap</code> should become <code>std.HashMapWithContext</code> and that <code>std.AutoHashMap</code> should become <code>std.HashMap</code>. I'm happy to defer to the core team's expertise on how to manage the transition period.</p><p>Now, to be sure, the core of this proposal could be summarily dismissed as a "skill issue". On the one hand, reading documentation or the <code>std</code> library code quickly reveals the existence of the <code>Auto...</code> types. And on the other, learning to write reasonably useful hashing functions is a skill that will serve a budding programmer well.</p><p>I think this dismissal is a mistake. In my personal experience, Zig's extremely legible standard library code and thoughtful approach to default implementations has helped me grow as a programmer in ways I never anticipated. By providing friction in the right places, the language has steered me towards better design and more correct code. In this particular instance, I think juice, while worth an eventual squeeze, might come at an off-putting price for a beginner. To wit, I didn't learn to comfortably reach for hash maps from Zig; I learned it from Rust.</p><p>This is more of an addendum, but I'd like to also propose the addition of <code>std.HashSet(T)</code> as well, as in <a href="https://github.com/ziglang/zig/issues/6919" target="_blank">#6919</a>. My reason for doing so, though, is different. For example, I would be happy to see a simple implementation like</p><pre><code class="zig"><span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">std</span><span class="error">.HashSet</span><span class="punctuation bracket">(</span><span class="variable">K</span><span class="punctuation bracket">)</span> <span class="type builtin">type</span> <span class="punctuation bracket">{</span>
    <span class="keyword return">return</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="function">ArrayAutoHashMapUnmanaged</span><span class="punctuation bracket">(</span><span class="variable">K</span><span class="punctuation delimiter">,</span> <span class="type builtin">void</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>The reason I would like to ask for this addition to the standard library is not functional but pedagogical: again, realizing that you <em>can</em> implement a <code>HashSet</code> type by creating a <code>HashMap</code> type with a zero-sized value type is a beautiful realization that I don't want to deny a beginner Zig programmer; the challenge is that coming to that realization on one's own is nontrivial.</p><h1>Managed vs. Unmanaged and ArrayLists</h1><p>You could be forgiven for thinking that <code>Vec&lt;T&gt;</code> translates to Zig's <code>@Vector</code>—that's Rust's (really C++'s) fault; choosing the name <code>Vec</code> for this data structure was an awful mistake. It's also such an old one that I can't hold it against Rust. Zig's current answer is <code>std.ArrayList(T)</code>. I don't mind it as a name: "Array" to me signals contiguity, while "List" suggests that you can grow it. The problem is that actually you really want <code>std.ArrayListUnmanaged(T)</code>. There's room for difference of opinions on this, but here are three reasons that convinced me of this:</p><h2>Initialization</h2><p>You can default-initialize <code>std.ArrayListUnmanaged(T)</code>, as in</p><pre><code class="zig"><span class="type qualifier">var</span> <span class="variable">list</span><span class="punctuation delimiter">:</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="function">ArrayListUnmanaged</span><span class="punctuation bracket">(</span><span class="variable">T</span><span class="punctuation bracket">)</span> = <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Actually, with Zig's upcoming "decl literal" syntax, it becomes preferred to write something like <code>.empty</code> instead of <code>.{}</code>. The reason to prefer this over <code>.{}</code> is that making it possible to initialize a struct of type <code>S</code> with <code>.{}</code> requires you to set default values for all of the fields of <code>S</code>; but <code>std.ArrayListUnmanaged(T)</code> has two fields, <code>items</code> and <code>capacity</code>, and it is a mistake to override one default value without also setting the other.</p><p>Since Zig has no "default" allocator, <code>std.ArrayList(T)</code> must either be initialized completely by hand or by calling <code>init(allocator)</code>. If you compose a larger struct by including a <code>std.ArrayList(T)</code>, that means you cannot default-init your larger struct either and must write an <code>init</code> function.</p><h2>Size</h2><p><code>@sizeOf(std.ArrayList(T) == 5 * @sizeOf(usize)</code>, while <code>@sizeOf(std.ArrayListUnmanaged(T)) == 3 * @sizeOf(usize)</code>. This is because <code>std.ArrayList(T)</code> takes possession of a <code>std.mem.Allocator</code> object, which it uses to manage its allocation as you interact with the <code>ArrayList</code>, while <code>std.ArrayListUnmanaged</code> does not, instead requiring you to pass the same <code>Allocator</code> as an argument each time you execute a call which could allocate or deallocate memory.</p><p>I mistakenly thought that in Rust, which uses the borrow checker to manage memory for you, <code>Vec&lt;T&gt;</code> has size equal to only <code>2 * @sizeOf(usize)</code>, which would be ideal for a type you'd like to pass around a lot. It appears that actually by default it has the same size as <code>std.ArrayListUnmanaged</code>. Some other Rust containers like those in the <code>ecow</code> crate <em>do</em> manage this by hiding both the <code>capacity</code> field (and the <code>Allocator</code>, when you're using one with positive size) inside its heap allocation. I don’t think Zig should adopt this sleight of hand for the standard container type.</p><h2>Optimizability</h2><p>I've read—although here I have to joyfully confess my lack of expertise—that making the <code>Allocator</code> a parameter as opposed to a field allows the LLVM backend (which as of 0.13 is the main way Zig produces machine code) to "devirtualize" the allocation calls.</p><p>Here's my understanding of what that means: in Zig, a <code>std.mem.Allocator</code> is a type-erased interface for a number of different approaches to allocation, in much the same way that objects in an object-oriented programming language like C++ or Java might conform to an "interface" (or the way the Rust compiler will generate code for you if you pass something as <code>Box&lt;dyn Trait&gt;</code>).</p><p>Zig doesn't have first-class interfaces or traits; instead <code>std.mem.Allocator</code> follows a "pointer + vtable" pattern (making <code>std.mem.Allocator</code> a type that sometimes goes by the name "fat pointer"). If you open <code>Allocator.zig</code> in Zig's standard library, you'll see that the definition of an <code>Allocator</code> type has two fields, which I'll summarize as:</p><pre><code class="zig"><span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">Allocator</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
	<span class="field">ptr</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="type builtin">anyopaque</span><span class="punctuation delimiter">,</span>
	<span class="field">vtable</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="type qualifier">const</span> <span class="variable">VTable</span><span class="punctuation delimiter">,</span>

	<span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">VTable</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
	    <span class="variable">alloc</span><span class="error">: *const fn // …,
	    resize: *const fn // …,
	    free: *const fn</span> <span class="comment">// …,</span>
    <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>That is, <code>Allocator</code> has two fields: <code>ptr</code> and <code>vtable</code>. Both of these are pointers; <code>ptr</code> to an unspecified type (<code>anyopaque</code>) and <code>vtable</code> to a <code>const VTable</code>. If you look at the definition of <code>VTable</code>, which I've abridged above, you'll see that it contains only function pointers; the methods on the <code>Allocator</code> struct call through these function pointers to actually do the allocation work. When you set up an <code>Allocator</code> in Zig, it's typically a two-step process. For example, most of my Advent of Code solutions (actually, most of my Zig programs full stop) begin with the following lines:</p><pre><code class="zig"><span class="type qualifier">var</span> <span class="variable">gpa</span><span class="punctuation delimiter">:</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span> = <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="variable">defer</span> <span class="variable">_</span> = <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="error">;</span>
<span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>The <code>gpa</code> variable must be <code>var</code> rather than <code>const</code> because <code>allocator()</code> captures a mutable pointer to it—under the hood, the <code>allocator()</code> function looks something like this</p><pre><code class="zig"><span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">allocator</span><span class="punctuation bracket">(</span><span class="parameter">self</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="function builtin">@This</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">mem</span><span class="punctuation delimiter">.</span><span class="field">Allocator</span> <span class="punctuation bracket">{</span>
	<span class="keyword return">return</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
		<span class="punctuation delimiter">.</span><span class="field">ptr</span> = <span class="variable">self</span><span class="punctuation delimiter">,</span>
		<span class="comment">// yes, we are returning a pointer </span>
		<span class="comment">// to what appears to be a local variable!</span>
		<span class="comment">// this is fine because the contents of the literal</span>
		<span class="comment">// are completely known at compile time,</span>
		<span class="comment">// so the literal actually has a static lifetime.</span>
		<span class="punctuation delimiter">.</span><span class="field">vtable</span> = <span class="operator">&</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
			<span class="comment">// these are functions implemented in </span>
			<span class="comment">// general_purpose_allocator.zig</span>
			<span class="punctuation delimiter">.</span><span class="field">alloc</span> = <span class="variable">alloc</span><span class="punctuation delimiter">,</span>
			<span class="punctuation delimiter">.</span><span class="field">resize</span> = <span class="variable">resize</span><span class="punctuation delimiter">,</span>
			<span class="punctuation delimiter">.</span><span class="field">free</span> = <span class="variable">free</span><span class="punctuation delimiter">,</span>
		<span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span>
	<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>I'm told (although I have to continue to joyfully confess that I am not an expert!) that calling functions through function pointers can be expensive. This makes sense—you have to prepare the computer to jump to an essentially arbitrary section of code to run, whereas with a "normal" function call, you know where you're going already.</p><p>Now, there are ways to mitigate this expense: one of them is "devirtualization", which as far as I understand means that if the compiler knows that the function pointer is always pointing to the same place in code, when it optimizes, it can replace the "virtual" function call with a "normal" one.</p><p>The point is that for <code>std.ArrayListUnmanaged(T)</code>, the compiler is far more likely to be able to come to this conclusion: because the <code>Allocator</code> only ever appears as a function parameter (and function parameters are always <code>const</code> in Zig), the chances of the compiler realizing that it never changes are much higher, since you cannot change fields of a <code>const</code> struct, and you cannot reach through and change values on the other side of the <code>*const VTable</code> either. But for <code>std.ArrayList(T)</code>, if you take (as you must) a mutable pointer to the <code>ArrayList</code>, suddenly, while it is not possible for you to change values on the other side of <code>*const VTable</code>, you <em>can</em> change out that <code>*const VTable</code> for another one wholesale. There's no reason you <em>would,</em> and I doubt that anyone <em>does,</em> but the possibility is more likely to make the compiler go "nah, too risky, I can't devirtualize that".</p></div></div>
  </div>

    </div>
    <div id="footer-links">
      <img src="/rc_logo.png" style="height:1em;
      width:auto;">
      Want to become a better programmer?
      <a href="https://www.recurse.com/scout/click?t=481004d6b700a153d74901f056b2c9f0">
        Join the Recurse Center!
      </a>
    </div>
  </body>
</html>
